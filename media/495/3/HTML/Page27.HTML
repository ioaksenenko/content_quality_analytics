<!DOCTYPE html>
<html>

<head>
    <meta http-equiv="content-type" content="text/html" charset="utf-8" />
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML-full"></script>
    <link href="https://new-online.tusur.ru/theme/fdo/ims/course_style.css" type="text/css" rel="stylesheet" />
</head>

<body>
    <div>
        <h3>3.5.2 Многопоточная обработка</h3>
        <p>Если <math xmlns="http://www.w3.org/1998/Math/MathML">
                <mstyle mathsize="100%" displaystyle="true">
                    <mi xmlns="http://www.w3.org/1998/Math/MathML">L</mi>
                </mstyle>
            </math>&#160;–&#160;метка некоторого места в программе, то команда</p>
        <p align="center"><b>fork &#160;</b><math xmlns="http://www.w3.org/1998/Math/MathML">
                <mstyle mathsize="100%" displaystyle="true">
                    <mi xmlns="http://www.w3.org/1998/Math/MathML">L</mi>
                </mstyle>
            </math></p>
        <p>передает управление на метку <math xmlns="http://www.w3.org/1998/Math/MathML">
                <mstyle mathsize="100%" displaystyle="true">
                    <mi xmlns="http://www.w3.org/1998/Math/MathML">L</mi>
                </mstyle>
            </math>, а также и на следующую команду в тексте программы. В&#160;результате создается эффект, что с этого момента два процессора одновременно исполняют одну и ту же программу; каждый из них независимо обрабатывает свою последовательность команд. Поскольку каждая такая последовательность обработки может снова разветвиться, эта техника получила название <i>многопоточной обработки</i>&#160;[17, 18].</p>
        <p>Введя способ разбиения одного процесса на два, мы нуждаемся и в способе слияния двух процессов в один. Проще всего ввести команду <b>join</b>, которая может выполниться только при одновременном исполнении ее <i>двумя</i> процессами. Первый достигший этой команды процесс должен ждать, когда ее достигнет другой. После этого уже только один процесс продолжает исполнение последующих команд.</p>
        <p>Разновидность команды ветвления до сих пор используется в операционной системе UNIX. При этом ветвление не подразумевает переход по метке. Его эффект заключается во взятии совершенно новой копии всей памяти программы и передачи этой копии новому процессу. Как исходный, так и новый процессы продолжают исполнение с команды, следующей за командой ветвления. У&#160;каждого процесса есть средство определить, является ли он <i>порождающим</i> (отец) или <i>порождаемым</i> (сын). Выделение процессам непересекающихся участков памяти снимает основные трудности и опасности многопоточной обработки, но может быть неэффективным как по времени, так и по объему памяти. Это означает, что параллелизм допустим только на самом внешнем (самом глобальном) уровне задания, а использование его в мелком масштабе затруднительно.</p>
    </div>
</body>

</html>